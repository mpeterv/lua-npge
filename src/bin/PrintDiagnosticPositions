#!/usr/bin/env lua

-- lua-npge, Nucleotide PanGenome explorer (Lua module)
-- Copyright (C) 2014-2015 Boris Nagaev
-- See the LICENSE file for terms of use.

local npge = require 'npge'
local treelua = require 'treelua'

local bs_fname = assert(arg[1])
local seqs_fname = assert(arg[2]) -- TODO remove this argument
local ndiag = assert(tonumber(arg[3]))
local tree_fname = assert(arg[4]) -- TODO

local seqs_lines = io.lines(seqs_fname)
local bs_lines = io.lines(bs_fname)
local seqs = npge.io.ReadSequencesFromFasta(seqs_lines)
local bs = npge.io.ReadFromBs(bs_lines, seqs)
local tree = treelua.fromNewick(io.open(tree_fname):read('*a'))

local function findDiagnosticPositions(alignment)
    local good_col = npge.alignment.goodColumns(alignment)
    local length = #good_col
    local diagnostic_positions = {}

    local function isSubstitution(i)
        if good_col[i] == 100 then
            return false
        end
        local seen = {}
        for _, text in ipairs(alignment) do
            local c = text:sub(i, i)
            if c == '-' or c == 'N' then
                return false
            end
            seen[c] = true
        end
        local nseen = 0
        for c in pairs(seen) do
            nseen = nseen + 1
        end
        return nseen == 2
    end

    local function isPerfect(start, stop)
        if start >= 1 and stop <= length then
            for i = start, stop do
                if good_col[i] ~= 100 then
                    return false
                end
            end
            return true
        end
        return false
    end

    for i = 1, length do
        if isSubstitution(i) and isPerfect(i - ndiag, i - 1) and isPerfect(i + 1, i + ndiag) then
            table.insert(diagnostic_positions, i)
        end
    end
    return diagnostic_positions
end

local function partitionByColumn(alignment, col)
    local p = {}
    local first = alignment[1]:sub(col, col)
    for _, text in ipairs(alignment) do
        if text:sub(col, col) == first then
            table.insert(p, '0')
        else
            table.insert(p, '1')
        end
    end
    return table.concat(p)
end

local function genomesByPartition(partition, genomes)
    local clade0 = {}
    local clade1 = {}
    for g, genome in ipairs(genomes) do
        if partition:sub(g, g) == '0' then
            table.insert(clade0, genome)
        else
            table.insert(clade1, genome)
        end
    end
    return clade0, clade1
end

local function alignmentForGenomes(block, genomes)
    assert(block:size(), #genomes)
    local genome2fr = {}
    for fr in block:iterFragments() do
        local genome = assert(fr:sequence():genome())
        assert(not genome2fr[genome])
        genome2fr[genome] = fr
    end
    local alignment = {}
    for _, genome in ipairs(genomes) do
        local fr = assert(genome2fr[genome])
        table.insert(alignment, block:text(fr))
    end
    return alignment
end

local function cladeToString(clade)
    return ("{%s}"):format(table.concat(clade, ','))
end

-- TODO move to tree.lua
local function iterEdges(tree)
    return coroutine.wrap(function()
        local leafs = tree:leafs()
        local root = leafs[1]
        for node, level, parent, edge in tree:iterDepth(root) do
            if edge then
                coroutine.yield(edge, node, parent)
            end
        end
    end)
end

-- TODO move to tree.lua
local function cladeByEdge(edge, node, bad_node, tree)
    local bad_nodes = {[bad_node] = true}
    local clade = {}
    for node, level, parent, edge in tree:iterDepth(node) do
        if bad_nodes[node] or bad_nodes[parent] then
            bad_nodes[node] = true
        elseif tree:isLeaf(node) then
            table.insert(clade, node)
        end
    end
    return clade
end

-- TODO move to tree.lua
local function cladesOfTree(tree)
    return coroutine.wrap(function()
        for edge, node1, node2 in iterEdges(tree) do
            local clade = cladeByEdge(edge, node1, node2, tree)
            coroutine.yield(clade, edge)
        end
    end)
end

local function cladeOfNames(clade)
    local clade_of_names = {}
    for _, leaf in ipairs(clade) do
        table.insert(clade_of_names, leaf.name)
    end
    return clade_of_names
end

local function partitionByClade(clade, genomes)
    local clade_set = {}
    for _, genome in ipairs(clade) do
        clade_set[genome] = true
    end
    local ifhas = clade_set[genomes[1]] and '0' or '1'
    local ifnothas = clade_set[genomes[1]] and '1' or '0'
    local p = {}
    for _, genome in ipairs(genomes) do
        table.insert(p, clade_set[genome] and ifhas or ifnothas)
    end
    return table.concat(p)
end

local function isStem(name)
    -- FIXME
    return name:match('^s')
end

local genomes = npge.algo.Genomes(bs)
local partition2weght = {}
for block, name in bs:iterBlocks() do
    if isStem(name) then
        local alignment = alignmentForGenomes(block, genomes)
        local diagnostic_positions = findDiagnosticPositions(alignment)
        for _, pos in ipairs(diagnostic_positions) do
            local partition = partitionByColumn(alignment, pos)
            partition2weght[partition] = (partition2weght[partition] or 0) + 1
        end
    end
end

local items = {}
for partition, weight in pairs(partition2weght) do
    table.insert(items, {partition=partition, weight=weight})
end
table.sort(items, function(item1, item2)
    return item1.weight > item2.weight
end)

for _, item in ipairs(items) do
    local clade0, clade1 = genomesByPartition(item.partition, genomes)
    print(cladeToString(clade0), cladeToString(clade1), item.weight)
end

-- set lengths of the tree branches according to the partitions
for clade, edge in cladesOfTree(tree) do
    local clade_of_names = cladeOfNames(clade)
    local partition = partitionByClade(clade_of_names, genomes)
    local weight = partition2weght[partition] or 0
    edge.length = weight
end
-- remove names of non-leaf nodes
for node in tree:iterNodes() do
    if not tree:isLeaf(node) then
        node.name = nil
    end
end
print(treelua.toNewick(tree))

-- TODO find discrepancies with the tree
-- TODO print block names and positions of discrepancies
